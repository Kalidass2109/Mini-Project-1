{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Helvetica-Oblique;
}
{\colortbl;\red255\green255\blue255;\red63\green105\blue30;\red85\green142\blue40;\red0\green0\blue0;
\red86\green156\blue214;\red170\green170\blue170;\red206\green145\blue120;\red0\green0\blue0;\red102\green177\blue50;
\red181\green206\blue168;\red79\green147\blue39;\red255\green255\blue255;\red78\green146\blue38;\red79\green147\blue40;
\red237\green237\blue237;\red238\green238\blue237;\red77\green145\blue37;}
{\*\expandedcolortbl;;\cssrgb\c30831\c47797\c15540;\cssrgb\c39975\c61335\c20601;\cssrgb\c0\c0\c0;
\csgenericrgb\c33725\c61176\c83922;\csgenericrgb\c66667\c66667\c66667;\csgenericrgb\c80784\c56863\c47059;\cssrgb\c0\c1\c1;\cssrgb\c46532\c73327\c25364;
\csgenericrgb\c70980\c80784\c65882;\cssrgb\c37145\c63014\c20190;\cssrgb\c100000\c100000\c100000\c0;\cssrgb\c36812\c62640\c19580;\cssrgb\c37255\c63137\c20392;
\cssrgb\c94510\c94510\c94510;\cssrgb\c94614\c94614\c94496;\cssrgb\c36587\c62387\c19171;}
\paperw11900\paperh16840\margl1440\margr1440\vieww17940\viewh8600\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 Microservices\
++++++++++++++++\
\
What is Monolith Architecture\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97> If We develop all the functionalities in single project then it is called as Monolith architecture based application.\
\'97> We will package our application as a jar/war to deploy into server.\
\'97> As monolith application contains all functionalities, it will become fat jar/war.\
\
Advantages\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
1) Simple to develop\
2) Everything is available at one place\
3) Configuration required only once\
\
Dis-Advantages\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
1) Difficult to maintain\
2) Dependencies among the functionalities\
3) Single Point of Failure\
4) Entire Project Deployment\
\
\
*********** To Overcome the problem of Monolith, Microservices architecture came into market *****************\
\'97> Microservices is not programming language\
\'97> Microservices is not a framework\
\'97> Microservices is not an Specification API\
\'97> Microservices is an architectural design pattern.\
\'97> Microservices suggesting to develop application functionalities with loosely coupling \
\'97> In Microservices architecture we don\'92t develop all the functionalities in single project. We will divide\
       Project functionalities into several REST APIS\
\
*********** Note: One REST API is called as one Microservices ******************\
\'97> Microservices architecture based project means collection of REST APIs.\
\'97> Microservices is not related to only java. Any programming language specific project can use Microservices\
      Architecture.\
\
Advantages\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
1) Loosely Coupling\
2) Easy to Maintain\
3) Faster Development\
4) Quick Deployment\
5) Faster Releases\
6) Less Downtime\
7) Technology Independence\
\
Dis-Advantages\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
1) Bounded Context\
2) Lot of configurations\
3) Visibility \
4) Pack of cards\
\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
Microservices Architecture\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97> We don\'92t have any fixed architecture for Microservices\
\'97> People are customising microservices architecture according to their requirement\
\'97> Most of the project will use below components in Microservices Architecture.\
\
1) Service Registry (Eureka Server)\
2) Services (REST APIs)\
3) Interservice Communication (FeginClient)\
4) API Gateway (Zuul Proxy)\
\
\
\
Service Registry\
+++++++++++++++++++\
\'97> Service Registry acts as DB of services available in the project.\
\'97> It provides the details of all the services which are registered with Service Registry\
\'97> We can identify how many services available in the project.\
\'97> We can identify how many instances available for each service.\
\'97> We can use \'93Eureka Server\'94 as service registry\
\'97> Eureka Server provided by \'93Spring Cloud Netflix\'94 library.\
\
Services\
+++++++++++++++\
\'97> Services means REST APIs/ Microservices\
\'97> Services contains backend business logic\
\'97> In the project, some services will interact with DB\
\'97> In the project, some services will interact with third party REST API (external communication)\
\'97> In the project, some services will interact with another services with in the project (inter-service communication)\
\'97> For inter-service communication we will use feign-client\
\'97> To distribute the load, we can run one service with multiple Instances (Load Balancing).\
\
Note: We will register every service with Service Registry.\
\
API Gateway\
++++++++++++++++\
\'97> API Gateway is used to manage our backend apis of the project\
\'97> API Gateway acts as mediator between end users and backend apis\
\'97> API Gateway can filter logic to decide request processing \
\'97> API Gateway will contain Routing logic (which request should go to which REST API)\
\'97> API Gateway also will be registered with Service Registry.\
\
\
\
\
========================================================================================\
Mini Project Implementation using Microservices Architecture\
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\
\
1) Service Registry \cf2 (Eureka Server) \cf0 \
2) Spring Boot Admin Server \cf3 (To monitor & manage boot applications or all backend actuators at one place)\cf4  \cf0 \
3) Zipkin Server \cf3 (Distributed Log Tracing) (https: //zipkin.io/pages/quickstart.html)\
         -(Backend APIs are executing, when a request sent that request processed by how many APIs in the backend and \
	  what is the time taken by each API that monitoring can be done by ZipKin Server)\cf0 \
\
\
Steps to develop Service Registry Application (Eureka Server)\
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\
1) Create Service Registry application with below dependency\
	a) EurekaServer (spring-cloud-starter-netflix-eureka-server)\
	b) web-starter\
	c) devtools\
2) Configure @EnableEurekaServer annotation in boot start class.\
3) Configure below properties in application.yml file\
\
Server:\
     port: 8761\
\
 \cf4 eureka:\
\pard\pardeftab720\partightenfactor0
\cf4   client:\
    register-with-eureka: false\
    fetch-registry: false\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
Note: If Service-Registry project port is 8761 then clients can discover service-registry and will register automatically with service-registry.\
If service-registry project running on any other port number then we have to register clients with service-registry manually.\
\
4) Once application started we can access Eureka Dashboard using below URL\
	URL: http://localhost:8761/\
\
\
\
Steps to develop Spring Boot Admin Server Project\
++++++++++++++++++++++++++++++++++++++++++++++++++++++\
1) Create Boot application with below dependencies\
	a) web-starter\
	b) devtools\
	c) admin-server (codecentric)\
2) Configure @EnableAdminServer annotation at boot start class\
3) Configure the port number and run the application (port: 1111)\
4) After application started, access Admin Server UI using app-url\
	URL: http://localhost:1111/\
\
\
\
Steps to work with Zipkin Server\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++\
1) Download Zipkin server jar from website\
	Site URL: https://zipkin.io/pages/quickstart.html\
2) Run the zipkin server jar from command prompt\
	cmd: java -jar <jar-file-name>\
Note: Zipkin server will run on 9411 port number\
3) Access Zipkin server dashboard in browser\
	URL: http://localhost:9411/\
\
\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
Steps to develop GREET-API (This will act as client of Eureka server, Admin Server, Zipkin Server)\
+++++++++++++++++++++++++++++++++++++++++++++++++++++++\
1) Create Spring Boot application with below dependencies\
	- eureka-discovery-client\
	- starter-web\
	- devtools\
	- actuator\
	- sleuth \
	- zipkin\
	- admin-client\
2) Configure @EnableDiscoveryClient annotation at start class\
3) Create RestController with required method\
4) Configure below properties in application.yml file\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97application.yml\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\pardeftab720\partightenfactor0

\f1\fs24 \cf5 spring\cf6 :\cf0 \
\cf6   \cf5 application\cf6 :\cf0 \
\cf6     \cf5 name\cf6 : \cf7 GREET-API\cf0 \
\cf6   \cf5 boot\cf6 :\cf0 \
\cf6     \cf5 admin\cf6 :\cf0 \
\cf6       \cf5 client\cf6 :\cf0 \
\cf6         \cf5 url\cf6 : \cf7 http://localhost:1111/\cf0 \
\cf5 eureka\cf6 :\cf0 \
\cf6   \cf5 client\cf6 :\cf0 \
\cf6     \cf5 service-url\cf6 :\cf0 \
\cf6       \cf5 defaultZone\cf6 : \cf7 http://localhost:8761/eureka\cf0 \
\cf5 management\cf6 : \cf0 \
\cf6   \cf5 endpoints\cf6 :\cf0 \
\cf6     \cf5 web\cf6 :\cf0 \
\cf6       \cf5 exposure\cf6 :\cf0 \
\cf6         \cf5 include\cf6 : \cf7 '*'
\f0\fs28 \cf0  \

\f1\fs24 \cf6 (1. Here we have configured Actuators also, by using an Actuators we can monitor our application.\
 2. We are accessing Actuators end points from \'93Admin Server\'94.\
 3. We are accessing Log Tracing details from \'93Zipkin Server\'94.\
 4. We are accessing API\'92s details, status, and URLs from \'93Eureka\'94.
\f0\fs28 \cf0 )
\f1\fs24 \cf6 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97
\f1\fs24 \cf5 \

\f0\fs28 \cf4 5) Run the application and check in Eureka Dashboard (It should display in eureka dashboard)\
6) Check Admin Server Dashboard (It should display) (we can access application details from here)\
	Ex: Beans, loggers, heap dump, thread dump, metrics, mappings etc\'85.\
7) Send Request to Rest API method\
8) Check zipkin Server UI and click on Run Query button\
	(it will display trace-id with details)\
\
\
\
\
Steps to develop WELCOME-API
\f1\fs24 \cf6  
\f0\fs28 \cf8 (This API gonna interact with GREET-API\cf4 \
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\
1) Create Spring Boot application with below dependencies\
	- web-starter\
	- devtools\
	- eureka-discovery-client\
	- feign-client.   \cf3  (By using Feign client, We can just write abstract method to communicate with other service.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf3 				Service name and URL mapping available in the service registry, Feign client will communicate with the \
				feign-client and get the url and talk to GREET-API)\cf4 \
\pard\pardeftab720\partightenfactor0
\cf4 	- admin-client\
	- zipkin-client\
	- sleuth  \cf3 (Sleuth will add ids for our log. trace id, and span Id will be available. We can trace the logs of our application\
			in Zipkin Server by using these trace id and span id)\cf4 \
	- actuator \cf3 (Actuators are used to access production ready features of our application to monitor the application, \
			Actuators are enabled in this API. So, We will access it in Admin Server)\cf4 \
2) Configure @EnablediscoveryClient & @EnableFeignClients annotations at boot start class\
3) Create Feignclient to access GREET-API\cf0 \
\cf4 \
\pard\pardeftab720\partightenfactor0

\f2\i \cf4 @FeignClient
\f0\i0 (name="GREET-API")\
public interface GreetApiClient \{\
	\
	
\f2\i @GetMapping
\f0\i0 ("/greet/\{name\}")\
	public String invokeGreetApi(
\f2\i @PathVariable
\f0\i0 ("name") String name);\
\
\}\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
4) Create RestController with required method \
Note: In Rest Controller we should have logic to access another REST API (GREET-API)\
\'97> For Interservice Communication we will use FeignClient\
\'97> Using FeignClient we can make rest call to another service using name of the service (no need of url)\
\'97> FeignClient will get service URL from service-registry based on service-name\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 @RestController\
public class WelcomeRestController \{	\
	private Logger logger=LoggerFactory.getLogger(WelcomeRestController.class);\
	\
	@Autowired\
	private GreetApiClient greetClient;\
	\
	@GetMapping("/welcome/\{name\}")\
	public String welcomeMsg(@PathVariable("name") String name) \{\
		logger.info("welcomeMsg() execution - start");\
		String welcomeMsg="Welcome to Microservices project...!";\
\
		\cf9 String greetMsg=greetClient.invokeGreetApi(name);\cf4 \
\
		logger.info("welcomeMsg() execution - end");\
		return greetMsg+", "+welcomeMsg;\
	\}\
\}\
\
5) Configure below properties in application.yml file\
\
\pard\pardeftab720\partightenfactor0

\f1\fs24 \cf5 server\cf6 :\cf0 \
\cf6   \cf5 port\cf6 : \cf10 9091\cf0 \
\cf5 spring\cf6 :\cf0 \
\cf6   \cf5 application\cf6 :\cf0 \
\cf6     \cf5 name\cf6 : \cf7 WELCOME-API\cf0 \
\cf6   \cf5 boot\cf6 :\cf0 \
\cf6     \cf5 admin\cf6 :\cf0 \
\cf6       \cf5 client\cf6 :\cf0 \
\cf6         \cf5 url\cf6 : \cf7 http://localhost:1111/\cf0 \
\cf5 eureka\cf6 :\cf0 \
\cf6   \cf5 client\cf6 :\cf0 \
\cf6     \cf5 serviceUrl\cf6 : \cf0 \
\cf6       \cf5 defaultZone\cf6 : \cf7 http://localhost:8761/eureka\cf0 \
\cf5 management\cf6 :\cf0 \
\cf6   \cf5 endpoints\cf6 :\cf0 \
\cf6     \cf5 web\cf6 :\cf0 \
\cf6       \cf5 exposure\cf6 :\cf0 \
\cf6         \cf5 include\cf6 : \cf7 '*'\cf0 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 \
6) Run WELCOME-API project (it should register in Eureka and Admin Server)\
7) Send Request to welcome-api (it should give final response)\
8) Verify zipkin Server Dashboard for log tracing \
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0  \cf4 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
GREET API URL : {\field{\*\fldinst{HYPERLINK "http://192.168.1.106:8080/actuator/info"}}{\fldrslt \cf11 \cb12 \expnd0\expndtw0\kerning0
\ul \ulc11 192.168.1.106:GREET-API\
}}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf8 \cb12 \expnd0\expndtw0\kerning0
WELCOME API URL: {\field{\*\fldinst{HYPERLINK "http://192.168.1.106:9091/actuator/info"}}{\fldrslt \cf11 \ul \ulc11 192.168.1.106:WELCOME-API:9091}}
\fs32 \cf14 \cb15 \ul \ulc14 \
\

\fs28 \cf8 \cb16 \ulc8 \
\cf8 \cb12 \ulnone \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
API Gateway\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97> API Gateway will act as mediator between client requests & backend apis\
\'97> API Gateway will provide single entrypoint to access our backend apis\
\'97> In API Gateway we will write mainly below 2 types of logics\
	1) Filters \
	2) Routing\
\'97> Filters are used to execute some logic before request processing and after request processing\
\'97> Routing is used to tell which request should go to which REST API\
\'97> In Spring Cloud, we have 2 options to create API Gateway\
	1) Zuul Proxy (old approach)\
	2) Spring Cloud Gateway (latest approach)\
\
Note: Zuul Proxy is \cf4 \cb1 \kerning1\expnd0\expndtw0 not \cf8 \cb12 \expnd0\expndtw0\kerning0
supported by latest versions of spring boot\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97> We are running Service Registry project with Eureka Server on 8761 port number\
\'97> Eureka Discovery Client applications are auto-registering with Eureka Server when port is 8761\
\'97> If we change Eureka Server port number then we have to register Eureka Client application with Eureka Server using \
       Below property in application.yml file\
\
\pard\pardeftab720\partightenfactor0

\f1\fs24 \cf5 \cb1 \kerning1\expnd0\expndtw0 eureka\cf6 :\cf0 \
\cf6   \cf5 client\cf6 :\cf0 \
\cf6     \cf5 serviceUrl\cf6 : \cf0 \
\cf6       \cf5 defaultZone\cf6 : \cf7 http://localhost:8761/eureka\
\

\f0\fs28 \cf8 Note: We should configure this property in eureka client application yml file.\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
Working \cf8 \cb12 \expnd0\expndtw0\kerning0
with Spring Cloud Gateway\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
1) Create Spring boot application with below dependencies\
	\'97> web-starter\
	\'97> eureka-client\
	\'97> cloud-gateway\
	\'97> devtools\
2) configure @EnableDiscoveryClient annotation at boot start class\
3) Configure API Gateway Routings in application.yml file like below\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97application.yml file\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\

\f1\fs24 \cf5 \cb1 \kerning1\expnd0\expndtw0 server\cf6 :\cf0 \
\cf6   \cf5 port\cf6 : \cf10 3333\cf0 \
\cf5 spring\cf6 :\cf0 \
\cf6   \cf5 cloud\cf6 :\cf0 \
\cf6     \cf5 gateway\cf6 :\cf0 \
\cf6       \cf5 discovery\cf6 :\cf0 \
\cf6         \cf5 locator\cf6 :\cf0 \
\cf6           \cf5 enabled\cf6 : \cf5 true\cf0 \
\cf6           \cf5 lower-case-service-id\cf6 : \cf5 true\cf0 \
\cf6       \cf5 routes\cf6 :\cf0 \
\cf6       - \cf5 id\cf6 : \cf7 welcome-api\cf0 \
\cf6         \cf5 uri\cf6 : \cf7 lb://WELCOME-API\cf0 \
\cf6         \cf5 predicates\cf6 :\cf0 \
\cf6         - \cf7 Path=/welcome/\{name\}\cf0 \
\cf6       - \cf5 id\cf6 : \cf7 greet-api\cf0 \
\cf6         \cf5 uri\cf6 : \cf7 lb://GREET-API\cf0 \
\cf6         \cf5 predicates\cf6 :\cf0 \
\cf6         - \cf7 Path=/greet/\{name\}\cf0 \
\cf6   \cf5 application\cf6 :\cf0 \
\cf6     \cf5 name\cf6 : \cf7 CLOUD-GATEWAY\
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf8 \cb12 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
In API Gateway we will have 3 types of logics\
\
	1) Route\
	2) Predicate\
	3) Filters\
\
\'97> Routing is used to defined which request should be processed by which REST API in backend. Routes will be configured\
       using predicate.\
\'97> Predicate: This is a Java 8 Function Predicate. The input type is a Spring Framework ServerWebExchange.\
       This lets you match on anything from the HTTP request, such as headers or parameters.\
\'97> Filters are used to manipulate incoming request and outgoing response of our application.\
\
Note: using Filters we can implement security also for our application.\
\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\pardeftab720\partightenfactor0
\cf8 \cb1 @Component\
public class MyPreFilter implements GlobalFilter\{\
\
	private Logger logger=LoggerFactory.getLogger(MyPreFilter.class);\
\
	@Override\
	public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) \{\
		\
		logger.info("MyPreFilter :: filter () method executed");\
		//Accessing HTTP Request information\
		ServerHttpRequest request=exchange.getRequest();\
		\
		HttpHeaders headers=request.getHeaders();\
		Set<String> keySet=headers.keySet();\
		\
		keySet.forEach(key->\{\
			List<String> values=headers.get(key);\
			System.out.println(key+" ::"+values);\
		\});\
		return chain.filter(exchange);\
	\}\
\}
\f1\fs24 \cf0 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf8 \cb12 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\'97> We can validate client given token in the request using Filter for security purpose\
\'97> We can write request and response tracking logic in Filter \
\'97> Filters are used to manipulate request & response of our application\
\'97> Any cross-cutting logics like security, logging, monitoring can be implemented using Filters \
\pard\pardeftab720\partightenfactor0
\cf8 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0
\cf8 \kerning1\expnd0\expndtw0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\cf8 \expnd0\expndtw0\kerning0
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf8  \cf8 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0
\cf8 \
\pard\pardeftab720\partightenfactor0
\cf8 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\cf8 \
Steps to implement Load Balance in Services\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\cf8 \
\'97> We will use \'93Environment\'94 class to get the current instance.\cf4 \cb1 \
\cf8 \cb12 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb1 	@Autowired\
	\cf3 private Environment env;\cf4 \
	\
	@GetMapping("/greet/\{name\}")\
	public String greetMsg(@PathVariable("name") String name) \{\
		logger.info("greetMsg() execution - start");\
		\
		\cf3 String port=env.getProperty("server.port");\
		String msg=name+", Good Morning...!! (Server Port :: "+port+ ")";\cf4 \
\
		logger.info("greetMsg() execution - end");\
		return msg;\
	\}\
\
\'97> Right click on Project click Run As -> click on Run Configurations -> select the application -> select Arguments\
	-> In VM arguments (We need to configure here if any arguments that you want to send JVM) -> give port like below\
	\'97> -Dserver.port=1010\
}